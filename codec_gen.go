// Package ais WARNING: this file is generated by parser_generator/main.go do not edit directly.
package ais

import "log"

func parseHeader(payload []byte, t *Codec, offset *uint) *Header {
	p := &Header{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["Header"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing MessageID as uint8

	num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
	// parsing RepeatIndicator as uint8

	num = extractNumber(payload, false, offset, 0)
	p.RepeatIndicator = uint8(num)
	// parsing UserID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.UserID = uint32(num)

	return p
}

func parsePositionReport(payload []byte, t *Codec, offset *uint) *PositionReport {
	p := &PositionReport{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["PositionReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing NavigationalStatus as uint8

	num = extractNumber(payload, false, offset, 0)
	p.NavigationalStatus = uint8(num)
	// parsing RateOfTurn as int16

	num = extractNumber(payload, true, offset, 0)
	p.RateOfTurn = int16(num)
	// parsing Sog as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}
	// parsing PositionAccuracy as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1 // parsing Longitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
	// parsing Latitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
	// parsing Cog as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
	// parsing TrueHeading as uint16

	num = extractNumber(payload, false, offset, 0)
	p.TrueHeading = uint16(num)
	// parsing Timestamp as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
	// parsing SpecialManoeuvreIndicator as uint8

	num = extractNumber(payload, false, offset, 0)
	p.SpecialManoeuvreIndicator = uint8(num)
	// parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
	// parsing Raim as bool

	num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateNoItdma = *parseCommunicationStateNoItdma(payload, t, offset)

	return p
}

func parseBaseStationReport(payload []byte, t *Codec, offset *uint) *BaseStationReport {
	p := &BaseStationReport{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["BaseStationReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing UtcYear as uint16

	num = extractNumber(payload, false, offset, 0)
	p.UtcYear = uint16(num)
	// parsing UtcMonth as uint8

	num = extractNumber(payload, false, offset, 0)
	p.UtcMonth = uint8(num)
	// parsing UtcDay as uint8

	num = extractNumber(payload, false, offset, 0)
	p.UtcDay = uint8(num)
	// parsing UtcHour as uint8

	num = extractNumber(payload, false, offset, 0)
	p.UtcHour = uint8(num)
	// parsing UtcMinute as uint8

	num = extractNumber(payload, false, offset, 0)
	p.UtcMinute = uint8(num)
	// parsing UtcSecond as uint8

	num = extractNumber(payload, false, offset, 0)
	p.UtcSecond = uint8(num)
	// parsing PositionAccuracy as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1 // parsing Longitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
	// parsing Latitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
	// parsing FixType as uint8

	num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
	// parsing LongRangeEnable as bool

	num = extractNumber(payload, true, offset, 0)
	p.LongRangeEnable = num == 1 // parsing Spare as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint16(num)
	// parsing Raim as bool

	num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateNoItdma = *parseCommunicationStateNoItdma(payload, t, offset)

	return p
}

func parseShipStaticData(payload []byte, t *Codec, offset *uint) *ShipStaticData {
	p := &ShipStaticData{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["ShipStaticData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	var str string

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing AisVersion as uint8

	num = extractNumber(payload, false, offset, 0)
	p.AisVersion = uint8(num)
	// parsing ImoNumber as uint32

	num = extractNumber(payload, false, offset, 0)
	p.ImoNumber = uint32(num)
	// parsing CallSign as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.CallSign = str
	// parsing Name as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str
	// parsing Type as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Type = uint8(num)
	// parsing Dimension as FieldDimension
	p.Dimension = *parseFieldDimension(payload, t, offset)
	// parsing FixType as uint8

	num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
	// parsing Eta as FieldETA
	// parsing MaximumStaticDraught as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.MaximumStaticDraught = Field10(num) / 10
	} else {
		p.MaximumStaticDraught = Field10(num)
	}
	// parsing Destination as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.Destination = str
	// parsing Dte as bool

	num = extractNumber(payload, true, offset, 0)
	p.Dte = num == 1 // parsing Spare as bool

	num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1
	return p
}

func parseAddressedBinaryMessage(payload []byte, t *Codec, offset *uint) *AddressedBinaryMessage {
	p := &AddressedBinaryMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["AddressedBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing SequenceNumber as uint8

	num = extractNumber(payload, false, offset, 0)
	p.SequenceNumber = uint8(num)
	// parsing DestinationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
	// parsing Retransmission as bool

	num = extractNumber(payload, true, offset, 0)
	p.Retransmission = num == 1 // parsing Spare as bool

	num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1 // parsing ApplicationID as FieldApplicationIdentifier
	p.BinaryData = payload[*offset : *offset+0]
	*offset += 0

	return p
}

func parseBinaryBroadcastMessage(payload []byte, t *Codec, offset *uint) *BinaryBroadcastMessage {
	p := &BinaryBroadcastMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["BinaryBroadcastMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
	// parsing ApplicationID as FieldApplicationIdentifier
	p.BinaryData = payload[*offset : *offset+0]
	*offset += 0

	return p
}

func parseStandardSearchAndRescueAircraftReport(payload []byte, t *Codec, offset *uint) *StandardSearchAndRescueAircraftReport {
	p := &StandardSearchAndRescueAircraftReport{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["StandardSearchAndRescueAircraftReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Altitude as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Altitude = uint16(num)
	// parsing Sog as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Sog = uint16(num)
	// parsing PositionAccuracy as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1 // parsing Longitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
	// parsing Latitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
	// parsing Cog as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
	// parsing Timestamp as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
	// parsing AltFromBaro as bool

	num = extractNumber(payload, true, offset, 0)
	p.AltFromBaro = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing Dte as bool

	num = extractNumber(payload, true, offset, 0)
	p.Dte = num == 1 // parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
	// parsing AssignedMode as bool

	num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1 // parsing Raim as bool

	num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateItdma = *parseCommunicationStateItdma(payload, t, offset)

	return p
}

func parseCoordinatedUTCInquiry(payload []byte, t *Codec, offset *uint) *CoordinatedUTCInquiry {
	p := &CoordinatedUTCInquiry{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["CoordinatedUTCInquiry"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing DestinationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
	// parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)

	return p
}

func parseAddessedSafetyMessage(payload []byte, t *Codec, offset *uint) *AddessedSafetyMessage {
	p := &AddessedSafetyMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["AddessedSafetyMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	var str string

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing SequenceNumber as uint8

	num = extractNumber(payload, false, offset, 0)
	p.SequenceNumber = uint8(num)
	// parsing DestinationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
	// parsing Retransmission as bool

	num = extractNumber(payload, true, offset, 0)
	p.Retransmission = num == 1 // parsing Spare as bool

	num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1 // parsing Text as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.Text = str

	return p
}

func parseSafetyBroadcastMessage(payload []byte, t *Codec, offset *uint) *SafetyBroadcastMessage {
	p := &SafetyBroadcastMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["SafetyBroadcastMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	var str string

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
	// parsing Text as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.Text = str

	return p
}

func parseGnssBroadcastBinaryMessage(payload []byte, t *Codec, offset *uint) *GnssBroadcastBinaryMessage {
	p := &GnssBroadcastBinaryMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["GnssBroadcastBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing Longitude as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude = FieldLatLonCoarse(num)
	}
	// parsing Latitude as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude = FieldLatLonCoarse(num)
	}
	// parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
	p.Data = payload[*offset : *offset+0]
	*offset += 0

	return p
}

func parseStandardClassBPositionReport(payload []byte, t *Codec, offset *uint) *StandardClassBPositionReport {
	p := &StandardClassBPositionReport{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["StandardClassBPositionReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing Sog as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}
	// parsing PositionAccuracy as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1 // parsing Longitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
	// parsing Latitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
	// parsing Cog as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
	// parsing TrueHeading as uint16

	num = extractNumber(payload, false, offset, 0)
	p.TrueHeading = uint16(num)
	// parsing Timestamp as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
	// parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
	// parsing ClassBUnit as bool

	num = extractNumber(payload, true, offset, 0)
	p.ClassBUnit = num == 1 // parsing ClassBDisplay as bool

	num = extractNumber(payload, true, offset, 0)
	p.ClassBDisplay = num == 1 // parsing ClassBDsc as bool

	num = extractNumber(payload, true, offset, 0)
	p.ClassBDsc = num == 1 // parsing ClassBBand as bool

	num = extractNumber(payload, true, offset, 0)
	p.ClassBBand = num == 1 // parsing ClassBMsg22 as bool

	num = extractNumber(payload, true, offset, 0)
	p.ClassBMsg22 = num == 1 // parsing AssignedMode as bool

	num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1 // parsing Raim as bool

	num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateItdma = *parseCommunicationStateItdma(payload, t, offset)

	return p
}

func parseExtendedClassBPositionReport(payload []byte, t *Codec, offset *uint) *ExtendedClassBPositionReport {
	p := &ExtendedClassBPositionReport{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["ExtendedClassBPositionReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	var str string

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing Sog as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}
	// parsing PositionAccuracy as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1 // parsing Longitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
	// parsing Latitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
	// parsing Cog as Field10

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
	// parsing TrueHeading as uint16

	num = extractNumber(payload, false, offset, 0)
	p.TrueHeading = uint16(num)
	// parsing Timestamp as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
	// parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
	// parsing Name as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str
	// parsing Type as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Type = uint8(num)
	// parsing Dimension as FieldDimension
	p.Dimension = *parseFieldDimension(payload, t, offset)
	// parsing FixType as uint8

	num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
	// parsing Raim as bool

	num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1 // parsing Dte as bool

	num = extractNumber(payload, true, offset, 0)
	p.Dte = num == 1 // parsing AssignedMode as bool

	num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1 // parsing Spare3 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare3 = uint8(num)

	return p
}

func parseAidsToNavigationReport(payload []byte, t *Codec, offset *uint) *AidsToNavigationReport {
	p := &AidsToNavigationReport{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["AidsToNavigationReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	var str string

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Type as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Type = uint8(num)
	// parsing Name as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str
	// parsing PositionAccuracy as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1 // parsing Longitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
	// parsing Latitude as FieldLatLonFine

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
	// parsing Dimension as FieldDimension
	p.Dimension = *parseFieldDimension(payload, t, offset)
	// parsing Fixtype as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Fixtype = uint8(num)
	// parsing Timestamp as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
	// parsing OffPosition as bool

	num = extractNumber(payload, true, offset, 0)
	p.OffPosition = num == 1 // parsing AtoN as uint8

	num = extractNumber(payload, false, offset, 0)
	p.AtoN = uint8(num)
	// parsing Raim as bool

	num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1 // parsing VirtualAtoN as bool

	num = extractNumber(payload, true, offset, 0)
	p.VirtualAtoN = num == 1 // parsing AssignedMode as bool

	num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1 // parsing Spare as bool

	num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1 // parsing NameExtension as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.NameExtension = str

	return p
}

func parseGroupAssignmentCommand(payload []byte, t *Codec, offset *uint) *GroupAssignmentCommand {
	p := &GroupAssignmentCommand{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["GroupAssignmentCommand"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing Longitude1 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude1 = FieldLatLonCoarse(num)
	}
	// parsing Latitude1 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude1 = FieldLatLonCoarse(num)
	}
	// parsing Longitude2 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude2 = FieldLatLonCoarse(num)
	}
	// parsing Latitude2 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude2 = FieldLatLonCoarse(num)
	}
	// parsing StationType as uint8

	num = extractNumber(payload, false, offset, 0)
	p.StationType = uint8(num)
	// parsing ShipType as uint8

	num = extractNumber(payload, false, offset, 0)
	p.ShipType = uint8(num)
	// parsing Spare2 as uint32

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint32(num)
	// parsing TxRxMode as uint8

	num = extractNumber(payload, false, offset, 0)
	p.TxRxMode = uint8(num)
	// parsing ReportingInterval as uint8

	num = extractNumber(payload, false, offset, 0)
	p.ReportingInterval = uint8(num)
	// parsing QuietTime as uint8

	num = extractNumber(payload, false, offset, 0)
	p.QuietTime = uint8(num)
	// parsing Spare3 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare3 = uint8(num)

	return p
}

func parseStaticDataReportA(payload []byte, t *Codec, offset *uint) *StaticDataReportA {
	p := &StaticDataReportA{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["StaticDataReportA"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var str string
	// parsing Name as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str

	return p
}

func parseStaticDataReportB(payload []byte, t *Codec, offset *uint) *StaticDataReportB {
	p := &StaticDataReportB{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["StaticDataReportB"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	var str string
	// parsing ShipType as uint8

	num = extractNumber(payload, false, offset, 0)
	p.ShipType = uint8(num)
	// parsing VendorIDName as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.VendorIDName = str
	// parsing VenderIDModel as uint8

	num = extractNumber(payload, false, offset, 0)
	p.VenderIDModel = uint8(num)
	// parsing VenderIDSerial as uint32

	num = extractNumber(payload, false, offset, 0)
	p.VenderIDSerial = uint32(num)
	// parsing CallSign as string
	str = extractString(payload, offset, 0, t.DropSpace)
	p.CallSign = str
	// parsing Dimension as FieldDimension
	p.Dimension = *parseFieldDimension(payload, t, offset)
	// parsing FixType as uint8

	num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
	// parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)

	return p
}

func parseStaticDataReport(payload []byte, t *Codec, offset *uint) *StaticDataReport {
	p := &StaticDataReport{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["StaticDataReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Reserved as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Reserved = uint8(num)
	// parsing PartNumber as bool

	num = extractNumber(payload, true, offset, 0)
	p.PartNumber = num == 1 // parsing ReportA as StaticDataReportA
	// parsing ReportB as StaticDataReportB

	return p
}

func parseLongRangeAisBroadcastMessage(payload []byte, t *Codec, offset *uint) *LongRangeAisBroadcastMessage {
	p := &LongRangeAisBroadcastMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["LongRangeAisBroadcastMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing PositionAccuracy as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1 // parsing Raim as bool

	num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1 // parsing NavigationalStatus as uint8

	num = extractNumber(payload, false, offset, 0)
	p.NavigationalStatus = uint8(num)
	// parsing Longitude as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude = FieldLatLonCoarse(num)
	}
	// parsing Latitude as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude = FieldLatLonCoarse(num)
	}
	// parsing Sog as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Sog = uint8(num)
	// parsing Cog as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Cog = uint16(num)
	// parsing PositionLatency as bool

	num = extractNumber(payload, true, offset, 0)
	p.PositionLatency = num == 1 // parsing Spare as bool

	num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1
	return p
}

func parseBinaryAcknowledgeData(payload []byte, t *Codec, offset *uint) *BinaryAcknowledgeData {
	p := &BinaryAcknowledgeData{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["BinaryAcknowledgeData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing DestinationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
	// parsing SequenceNumber as uint8

	num = extractNumber(payload, false, offset, 0)
	p.SequenceNumber = uint8(num)

	return p
}

func parseBinaryAcknowledge(payload []byte, t *Codec, offset *uint) *BinaryAcknowledge {
	p := &BinaryAcknowledge{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["BinaryAcknowledge"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)

	return p
}

func parseInterrogationStation1Message1(payload []byte, t *Codec, offset *uint) *InterrogationStation1Message1 {
	p := &InterrogationStation1Message1{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["InterrogationStation1Message1"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing StationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.StationID = uint32(num)
	// parsing MessageID as uint8

	num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
	// parsing SlotOffset as uint16

	num = extractNumber(payload, false, offset, 0)
	p.SlotOffset = uint16(num)

	return p
}

func parseInterrogationStation1Message2(payload []byte, t *Codec, offset *uint) *InterrogationStation1Message2 {
	p := &InterrogationStation1Message2{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["InterrogationStation1Message2"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
	// parsing MessageID as uint8

	num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
	// parsing SlotOffset as uint16

	num = extractNumber(payload, false, offset, 0)
	p.SlotOffset = uint16(num)

	return p
}

func parseInterrogationStation2(payload []byte, t *Codec, offset *uint) *InterrogationStation2 {
	p := &InterrogationStation2{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["InterrogationStation2"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing StationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.StationID = uint32(num)
	// parsing MessageID as uint8

	num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
	// parsing SlotOffset as uint16

	num = extractNumber(payload, false, offset, 0)
	p.SlotOffset = uint16(num)
	// parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)

	return p
}

func parseInterrogation(payload []byte, t *Codec, offset *uint) *Interrogation {
	p := &Interrogation{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["Interrogation"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
	// parsing Station1Msg1 as InterrogationStation1Message1
	// parsing Station1Msg2 as InterrogationStation1Message2
	// parsing Station2 as InterrogationStation2

	return p
}

func parseAssignedModeCommandData(payload []byte, t *Codec, offset *uint) *AssignedModeCommandData {
	p := &AssignedModeCommandData{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["AssignedModeCommandData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing DestinationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
	// parsing Offset as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Offset = uint16(num)
	// parsing Increment as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Increment = uint16(num)

	return p
}

func parseAssignedModeCommand(payload []byte, t *Codec, offset *uint) *AssignedModeCommand {
	p := &AssignedModeCommand{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["AssignedModeCommand"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)

	return p
}

func parseDataLinkManagementMessageData(payload []byte, t *Codec, offset *uint) *DataLinkManagementMessageData {
	p := &DataLinkManagementMessageData{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["DataLinkManagementMessageData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing Offset as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Offset = uint16(num)
	// parsing NumberOfSlots as uint8

	num = extractNumber(payload, false, offset, 0)
	p.NumberOfSlots = uint8(num)
	// parsing TimeOut as uint8

	num = extractNumber(payload, false, offset, 0)
	p.TimeOut = uint8(num)
	// parsing Increment as uint16

	num = extractNumber(payload, false, offset, 0)
	p.Increment = uint16(num)

	return p
}

func parseDataLinkManagementMessage(payload []byte, t *Codec, offset *uint) *DataLinkManagementMessage {
	p := &DataLinkManagementMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["DataLinkManagementMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
	var elems [4]DataLinkManagementMessageData
	elems[0] = *parseDataLinkManagementMessageData(payload, t, offset)
	elems[1] = *parseDataLinkManagementMessageData(payload, t, offset)
	elems[2] = *parseDataLinkManagementMessageData(payload, t, offset)
	elems[3] = *parseDataLinkManagementMessageData(payload, t, offset)
	p.Data = elems
	return p
}

func parseChannelManagementBroadcastData(payload []byte, t *Codec, offset *uint) *ChannelManagementBroadcastData {
	p := &ChannelManagementBroadcastData{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["ChannelManagementBroadcastData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing Longitude1 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude1 = FieldLatLonCoarse(num)
	}
	// parsing Latitude1 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude1 = FieldLatLonCoarse(num)
	}
	// parsing Longitude2 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Longitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude2 = FieldLatLonCoarse(num)
	}
	// parsing Latitude2 as FieldLatLonCoarse

	num = extractNumber(payload, true, offset, 0)
	if !t.FloatWithoutConversion {
		p.Latitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude2 = FieldLatLonCoarse(num)
	}

	return p
}

func parseChannelManagementUnicastData(payload []byte, t *Codec, offset *uint) *ChannelManagementUnicastData {
	p := &ChannelManagementUnicastData{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["ChannelManagementUnicastData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing AddressStation1 as uint32

	num = extractNumber(payload, false, offset, 0)
	p.AddressStation1 = uint32(num)
	// parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
	// parsing AddressStation2 as uint32

	num = extractNumber(payload, false, offset, 0)
	p.AddressStation2 = uint32(num)
	// parsing Spare3 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare3 = uint8(num)

	return p
}

func parseChannelManagement(payload []byte, t *Codec, offset *uint) *ChannelManagement {
	p := &ChannelManagement{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["ChannelManagement"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing ChannelA as uint16

	num = extractNumber(payload, false, offset, 0)
	p.ChannelA = uint16(num)
	// parsing ChannelB as uint16

	num = extractNumber(payload, false, offset, 0)
	p.ChannelB = uint16(num)
	// parsing TxRxMode as uint8

	num = extractNumber(payload, false, offset, 0)
	p.TxRxMode = uint8(num)
	// parsing LowPower as bool

	num = extractNumber(payload, true, offset, 0)
	p.LowPower = num == 1 // parsing Area as ChannelManagementBroadcastData
	// parsing Unicast as ChannelManagementUnicastData
	// parsing IsAddressed as bool

	num = extractNumber(payload, true, offset, 0)
	p.IsAddressed = num == 1 // parsing BwA as bool

	num = extractNumber(payload, true, offset, 0)
	p.BwA = num == 1 // parsing BwB as bool

	num = extractNumber(payload, true, offset, 0)
	p.BwB = num == 1 // parsing TransitionalZoneSize as uint8

	num = extractNumber(payload, false, offset, 0)
	p.TransitionalZoneSize = uint8(num)
	// parsing Spare4 as uint32

	num = extractNumber(payload, false, offset, 0)
	p.Spare4 = uint32(num)

	return p
}

func parseSingleSlotBinaryMessage(payload []byte, t *Codec, offset *uint) *SingleSlotBinaryMessage {
	p := &SingleSlotBinaryMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["SingleSlotBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing DestinationIDValid as bool

	num = extractNumber(payload, true, offset, 0)
	p.DestinationIDValid = num == 1 // parsing ApplicationIDValid as bool

	num = extractNumber(payload, true, offset, 0)
	p.ApplicationIDValid = num == 1 // parsing DestinationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
	// parsing Spare as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
	// parsing ApplicationID as FieldApplicationIdentifier
	p.Payload = payload[*offset : *offset+0]
	*offset += 0

	return p
}

func parseMultiSlotBinaryMessage(payload []byte, t *Codec, offset *uint) *MultiSlotBinaryMessage {
	p := &MultiSlotBinaryMessage{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["MultiSlotBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64

	p.Header = *parseHeader(payload, t, offset)
	// parsing Valid as bool

	num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1 // parsing DestinationIDValid as bool

	num = extractNumber(payload, true, offset, 0)
	p.DestinationIDValid = num == 1 // parsing ApplicationIDValid as bool

	num = extractNumber(payload, true, offset, 0)
	p.ApplicationIDValid = num == 1 // parsing DestinationID as uint32

	num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
	// parsing Spare1 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
	// parsing ApplicationID as FieldApplicationIdentifier
	p.Payload = payload[*offset : *offset+0]
	*offset += 0
	// parsing Spare2 as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)

	p.CommunicationStateItdma = *parseCommunicationStateItdma(payload, t, offset)

	return p
}

func parseFieldETA(payload []byte, t *Codec, offset *uint) *FieldETA {
	p := &FieldETA{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["FieldETA"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing Month as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Month = uint8(num)
	// parsing Day as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Day = uint8(num)
	// parsing Hour as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Hour = uint8(num)
	// parsing Minute as uint8

	num = extractNumber(payload, false, offset, 0)
	p.Minute = uint8(num)

	return p
}

func parseFieldDimension(payload []byte, t *Codec, offset *uint) *FieldDimension {
	p := &FieldDimension{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["FieldDimension"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing A as uint16

	num = extractNumber(payload, false, offset, 0)
	p.A = uint16(num)
	// parsing B as uint16

	num = extractNumber(payload, false, offset, 0)
	p.B = uint16(num)
	// parsing C as uint8

	num = extractNumber(payload, false, offset, 0)
	p.C = uint8(num)
	// parsing D as uint8

	num = extractNumber(payload, false, offset, 0)
	p.D = uint8(num)

	return p
}

func parseFieldApplicationIdentifier(payload []byte, t *Codec, offset *uint) *FieldApplicationIdentifier {
	p := &FieldApplicationIdentifier{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["FieldApplicationIdentifier"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing DesignatedAreaCode as uint16

	num = extractNumber(payload, false, offset, 0)
	p.DesignatedAreaCode = uint16(num)
	// parsing FunctionIdentifier as uint8

	num = extractNumber(payload, false, offset, 0)
	p.FunctionIdentifier = uint8(num)

	return p
}

func parseCommunicationStateItdma(payload []byte, t *Codec, offset *uint) *CommunicationStateItdma {
	p := &CommunicationStateItdma{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["CommunicationStateItdma"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing CommunicationStateIsItdma as bool

	num = extractNumber(payload, true, offset, 0)
	p.CommunicationStateIsItdma = num == 1 // parsing CommunicationState as uint32

	num = extractNumber(payload, false, offset, 0)
	p.CommunicationState = uint32(num)

	return p
}

func parseCommunicationStateNoItdma(payload []byte, t *Codec, offset *uint) *CommunicationStateNoItdma {
	p := &CommunicationStateNoItdma{}
	// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
	minBitsForValid, ok := t.minValidMap["CommunicationStateNoItdma"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}

	var num int64
	// parsing CommunicationState as uint32

	num = extractNumber(payload, false, offset, 0)
	p.CommunicationState = uint32(num)

	return p
}
