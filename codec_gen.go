
// WARNING: this file is generated by parser_generator/main.go do not edit directly.
package ais

func parseHeader(payload []byte, t *Codec, offset *uint) *Header {
	p := &Header{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["Header"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.RepeatIndicator = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.UserID = uint32(num)

	return p
}

func parsePositionReport(payload []byte, t *Codec, offset *uint) *PositionReport {
	p := &PositionReport{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["PositionReport"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.NavigationalStatus = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.RateOfTurn = int16(num)
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}
num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.TrueHeading = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.SpecialManoeuvreIndicator = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateNoItdma = parseCommunicationStateNoItdma(payload, t, offset)

	return p
}

func parseBaseStationReport(payload []byte, t *Codec, offset *uint) *BaseStationReport {
	p := &BaseStationReport{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["BaseStationReport"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.UtcYear = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.UtcMonth = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.UtcDay = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.UtcHour = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.UtcMinute = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.UtcSecond = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.LongRangeEnable = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint16(num)
num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateNoItdma = parseCommunicationStateNoItdma(payload, t, offset)

	return p
}

func parseShipStaticData(payload []byte, t *Codec, offset *uint) *ShipStaticData {
	p := &ShipStaticData{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["ShipStaticData"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.AisVersion = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.ImoNumber = uint32(num)
str = extractString(payload, offset, 0, t.DropSpace)
	p.CallSign = str
str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str
num = extractNumber(payload, false, offset, 0)
	p.Type = uint8(num)
p.Dimension = parseFieldDimension(patload, t, offset)
num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.MaximumStaticDraught = Field10(num) / 10
	} else {
		p.MaximumStaticDraught = Field10(num)
	}
str = extractString(payload, offset, 0, t.DropSpace)
	p.Destination = str
num = extractNumber(payload, true, offset, 0)
	p.Dte = num == 1num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1
	return p
}

func parseAddressedBinaryMessage(payload []byte, t *Codec, offset *uint) *AddressedBinaryMessage {
	p := &AddressedBinaryMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["AddressedBinaryMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.SequenceNumber = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
num = extractNumber(payload, true, offset, 0)
	p.Retransmission = num == 1num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1p.BinaryData = payload[*offset:*offset+0]
	*offset += 0

	return p
}

func parseBinaryBroadcastMessage(payload []byte, t *Codec, offset *uint) *BinaryBroadcastMessage {
	p := &BinaryBroadcastMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["BinaryBroadcastMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
p.BinaryData = payload[*offset:*offset+0]
	*offset += 0

	return p
}

func parseStandardSearchAndRescueAircraftReport(payload []byte, t *Codec, offset *uint) *StandardSearchAndRescueAircraftReport {
	p := &StandardSearchAndRescueAircraftReport{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["StandardSearchAndRescueAircraftReport"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Altitude = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.Sog = uint16(num)
num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.AltFromBaro = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.Dte = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateItdma = parseCommunicationStateItdma(payload, t, offset)

	return p
}

func parseCoordinatedUTCInquiry(payload []byte, t *Codec, offset *uint) *CoordinatedUTCInquiry {
	p := &CoordinatedUTCInquiry{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["CoordinatedUTCInquiry"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)

	return p
}

func parseAddessedSafetyMessage(payload []byte, t *Codec, offset *uint) *AddessedSafetyMessage {
	p := &AddessedSafetyMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["AddessedSafetyMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.SequenceNumber = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
num = extractNumber(payload, true, offset, 0)
	p.Retransmission = num == 1num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1str = extractString(payload, offset, 0, t.DropSpace)
	p.Text = str

	return p
}

func parseSafetyBroadcastMessage(payload []byte, t *Codec, offset *uint) *SafetyBroadcastMessage {
	p := &SafetyBroadcastMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["SafetyBroadcastMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
str = extractString(payload, offset, 0, t.DropSpace)
	p.Text = str

	return p
}

func parseGnssBroadcastBinaryMessage(payload []byte, t *Codec, offset *uint) *GnssBroadcastBinaryMessage {
	p := &GnssBroadcastBinaryMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["GnssBroadcastBinaryMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
p.Data = payload[*offset:*offset+0]
	*offset += 0

	return p
}

func parseStandardClassBPositionReport(payload []byte, t *Codec, offset *uint) *StandardClassBPositionReport {
	p := &StandardClassBPositionReport{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["StandardClassBPositionReport"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}
num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.TrueHeading = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.ClassBUnit = num == 1num = extractNumber(payload, true, offset, 0)
	p.ClassBDisplay = num == 1num = extractNumber(payload, true, offset, 0)
	p.ClassBDsc = num == 1num = extractNumber(payload, true, offset, 0)
	p.ClassBBand = num == 1num = extractNumber(payload, true, offset, 0)
	p.ClassBMsg22 = num == 1num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1
	p.CommunicationStateItdma = parseCommunicationStateItdma(payload, t, offset)

	return p
}

func parseExtendedClassBPositionReport(payload []byte, t *Codec, offset *uint) *ExtendedClassBPositionReport {
	p := &ExtendedClassBPositionReport{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["ExtendedClassBPositionReport"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}
num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.TrueHeading = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str
num = extractNumber(payload, false, offset, 0)
	p.Type = uint8(num)
p.Dimension = parseFieldDimension(patload, t, offset)
num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1num = extractNumber(payload, true, offset, 0)
	p.Dte = num == 1num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare3 = uint8(num)

	return p
}

func parseAidsToNavigationReport(payload []byte, t *Codec, offset *uint) *AidsToNavigationReport {
	p := &AidsToNavigationReport{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["AidsToNavigationReport"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Type = uint8(num)
str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str
num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}
p.Dimension = parseFieldDimension(patload, t, offset)
num = extractNumber(payload, false, offset, 0)
	p.Fixtype = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Timestamp = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.OffPosition = num == 1num = extractNumber(payload, false, offset, 0)
	p.AtoN = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1num = extractNumber(payload, true, offset, 0)
	p.VirtualAtoN = num == 1num = extractNumber(payload, true, offset, 0)
	p.AssignedMode = num == 1num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1str = extractString(payload, offset, 0, t.DropSpace)
	p.NameExtension = str

	return p
}

func parseGroupAssignmentCommand(payload []byte, t *Codec, offset *uint) *GroupAssignmentCommand {
	p := &GroupAssignmentCommand{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["GroupAssignmentCommand"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude1 = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude1 = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude2 = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude2 = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.StationType = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.ShipType = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.TxRxMode = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.ReportingInterval = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.QuietTime = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare3 = uint8(num)

	return p
}

func parseStaticDataReportA(payload []byte, t *Codec, offset *uint) *StaticDataReportA {
	p := &StaticDataReportA{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["StaticDataReportA"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    str = extractString(payload, offset, 0, t.DropSpace)
	p.Name = str

	return p
}

func parseStaticDataReportB(payload []byte, t *Codec, offset *uint) *StaticDataReportB {
	p := &StaticDataReportB{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["StaticDataReportB"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.ShipType = uint8(num)
str = extractString(payload, offset, 0, t.DropSpace)
	p.VendorIDName = str
num = extractNumber(payload, false, offset, 0)
	p.VenderIDModel = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.VenderIDSerial = uint32(num)
str = extractString(payload, offset, 0, t.DropSpace)
	p.CallSign = str
p.Dimension = parseFieldDimension(patload, t, offset)
num = extractNumber(payload, false, offset, 0)
	p.FixType = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)

	return p
}

func parseStaticDataReport(payload []byte, t *Codec, offset *uint) *StaticDataReport {
	p := &StaticDataReport{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["StaticDataReport"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Reserved = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.PartNumber = num == 1
	return p
}

func parseLongRangeAisBroadcastMessage(payload []byte, t *Codec, offset *uint) *LongRangeAisBroadcastMessage {
	p := &LongRangeAisBroadcastMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["LongRangeAisBroadcastMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, true, offset, 0)
	p.PositionAccuracy = num == 1num = extractNumber(payload, true, offset, 0)
	p.Raim = num == 1num = extractNumber(payload, false, offset, 0)
	p.NavigationalStatus = uint8(num)
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, false, offset, 0)
	p.Sog = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Cog = uint16(num)
num = extractNumber(payload, true, offset, 0)
	p.PositionLatency = num == 1num = extractNumber(payload, true, offset, 0)
	p.Spare = num == 1
	return p
}

func parseBinaryAcknowledgeData(payload []byte, t *Codec, offset *uint) *BinaryAcknowledgeData {
	p := &BinaryAcknowledgeData{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["BinaryAcknowledgeData"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.SequenceNumber = uint8(num)

	return p
}

func parseBinaryAcknowledge(payload []byte, t *Codec, offset *uint) *BinaryAcknowledge {
	p := &BinaryAcknowledge{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["BinaryAcknowledge"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)

	return p
}

func parseInterrogationStation1Message1(payload []byte, t *Codec, offset *uint) *InterrogationStation1Message1 {
	p := &InterrogationStation1Message1{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["InterrogationStation1Message1"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.StationID = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.SlotOffset = uint16(num)

	return p
}

func parseInterrogationStation1Message2(payload []byte, t *Codec, offset *uint) *InterrogationStation1Message2 {
	p := &InterrogationStation1Message2{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["InterrogationStation1Message2"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.SlotOffset = uint16(num)

	return p
}

func parseInterrogationStation2(payload []byte, t *Codec, offset *uint) *InterrogationStation2 {
	p := &InterrogationStation2{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["InterrogationStation2"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.StationID = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.MessageID = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.SlotOffset = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)

	return p
}

func parseInterrogation(payload []byte, t *Codec, offset *uint) *Interrogation {
	p := &Interrogation{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["Interrogation"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)

	return p
}

func parseAssignedModeCommandData(payload []byte, t *Codec, offset *uint) *AssignedModeCommandData {
	p := &AssignedModeCommandData{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["AssignedModeCommandData"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.Offset = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.Increment = uint16(num)

	return p
}

func parseAssignedModeCommand(payload []byte, t *Codec, offset *uint) *AssignedModeCommand {
	p := &AssignedModeCommand{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["AssignedModeCommand"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)

	return p
}

func parseDataLinkManagementMessageData(payload []byte, t *Codec, offset *uint) *DataLinkManagementMessageData {
	p := &DataLinkManagementMessageData{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["DataLinkManagementMessageData"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.Offset = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.NumberOfSlots = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.TimeOut = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Increment = uint16(num)

	return p
}

func parseDataLinkManagementMessage(payload []byte, t *Codec, offset *uint) *DataLinkManagementMessage {
	p := &DataLinkManagementMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["DataLinkManagementMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
var elems = make([]DataLinkManagementMessageData, 4)
elems[0] = parseDataLinkManagementMessageData(payload, t, offset)
elems[1] = parseDataLinkManagementMessageData(payload, t, offset)
elems[2] = parseDataLinkManagementMessageData(payload, t, offset)
elems[3] = parseDataLinkManagementMessageData(payload, t, offset)
p.Data = elems
	return p
}

func parseChannelManagementBroadcastData(payload []byte, t *Codec, offset *uint) *ChannelManagementBroadcastData {
	p := &ChannelManagementBroadcastData{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["ChannelManagementBroadcastData"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude1 = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude1 = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Longitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude2 = FieldLatLonCoarse(num)
	}
num = extractNumber(payload, true, offset, 0)
	if if !t.FloatWithoutConversion {
		p.Latitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude2 = FieldLatLonCoarse(num)
	}

	return p
}

func parseChannelManagementUnicastData(payload []byte, t *Codec, offset *uint) *ChannelManagementUnicastData {
	p := &ChannelManagementUnicastData{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["ChannelManagementUnicastData"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.AddressStation1 = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.AddressStation2 = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare3 = uint8(num)

	return p
}

func parseChannelManagement(payload []byte, t *Codec, offset *uint) *ChannelManagement {
	p := &ChannelManagement{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["ChannelManagement"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.ChannelA = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.ChannelB = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.TxRxMode = uint8(num)
num = extractNumber(payload, true, offset, 0)
	p.LowPower = num == 1num = extractNumber(payload, true, offset, 0)
	p.IsAddressed = num == 1num = extractNumber(payload, true, offset, 0)
	p.BwA = num == 1num = extractNumber(payload, true, offset, 0)
	p.BwB = num == 1num = extractNumber(payload, false, offset, 0)
	p.TransitionalZoneSize = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare4 = uint32(num)

	return p
}

func parseSingleSlotBinaryMessage(payload []byte, t *Codec, offset *uint) *SingleSlotBinaryMessage {
	p := &SingleSlotBinaryMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["SingleSlotBinaryMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, true, offset, 0)
	p.DestinationIDValid = num == 1num = extractNumber(payload, true, offset, 0)
	p.ApplicationIDValid = num == 1num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare = uint8(num)
p.Payload = payload[*offset:*offset+0]
	*offset += 0

	return p
}

func parseMultiSlotBinaryMessage(payload []byte, t *Codec, offset *uint) *MultiSlotBinaryMessage {
	p := &MultiSlotBinaryMessage{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["MultiSlotBinaryMessage"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    
	p.Header = parseHeader(payload, t, offset)
num = extractNumber(payload, true, offset, 0)
	p.Valid = num == 1num = extractNumber(payload, true, offset, 0)
	p.DestinationIDValid = num == 1num = extractNumber(payload, true, offset, 0)
	p.ApplicationIDValid = num == 1num = extractNumber(payload, false, offset, 0)
	p.DestinationID = uint32(num)
num = extractNumber(payload, false, offset, 0)
	p.Spare1 = uint8(num)
p.Payload = payload[*offset:*offset+0]
	*offset += 0
num = extractNumber(payload, false, offset, 0)
	p.Spare2 = uint8(num)

	p.CommunicationStateItdma = parseCommunicationStateItdma(payload, t, offset)

	return p
}

func parseFieldETA(payload []byte, t *Codec, offset *uint) *FieldETA {
	p := &FieldETA{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["FieldETA"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.Month = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Day = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Hour = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.Minute = uint8(num)

	return p
}

func parseFieldDimension(payload []byte, t *Codec, offset *uint) *FieldDimension {
	p := &FieldDimension{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["FieldDimension"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.A = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.B = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.C = uint8(num)
num = extractNumber(payload, false, offset, 0)
	p.D = uint8(num)

	return p
}

func parseFieldApplicationIdentifier(payload []byte, t *Codec, offset *uint) *FieldApplicationIdentifier {
	p := &FieldApplicationIdentifier{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["FieldApplicationIdentifier"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.DesignatedAreaCode = uint16(num)
num = extractNumber(payload, false, offset, 0)
	p.FunctionIdentifier = uint8(num)

	return p
}

func parseCommunicationStateItdma(payload []byte, t *Codec, offset *uint) *CommunicationStateItdma {
	p := &CommunicationStateItdma{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["CommunicationStateItdma"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, true, offset, 0)
	p.CommunicationStateIsItdma = num == 1num = extractNumber(payload, false, offset, 0)
	p.CommunicationState = uint32(num)

	return p
}

func parseCommunicationStateNoItdma(payload []byte, t *Codec, offset *uint) *CommunicationStateNoItdma {
	p := &CommunicationStateNoItdma{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(0)
    minBitsForValid, ok := t.minValidMap["CommunicationStateNoItdma"]
	if !ok {
		minBitsForValid = minlength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
	var num int
	var str string
    num = extractNumber(payload, false, offset, 0)
	p.CommunicationState = uint32(num)

	return p
}

