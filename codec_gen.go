// package ais WARNING: This file is generated by parser_generator/main.go do not edit directly.
package ais

import "log"

var mapper = map[int64]func(t *Codec, payload []byte, offset *uint) Packet{
	1:  parsePositionReport,
	2:  parsePositionReport,
	3:  parsePositionReport,
	4:  parseBaseStationReport,
	5:  parseShipStaticData,
	6:  parseAddressedBinaryMessage,
	7:  parseBinaryAcknowledge,
	8:  parseBinaryBroadcastMessage,
	9:  parseStandardSearchAndRescueAircraftReport,
	10: parseCoordinatedUTCInquiry,
	11: parseBaseStationReport,
	12: parseAddessedSafetyMessage,
	13: parseBinaryAcknowledge,
	14: parseSafetyBroadcastMessage,
	15: parseInterrogation,
	16: parseAssignedModeCommand,
	17: parseGnssBroadcastBinaryMessage,
	18: parseStandardClassBPositionReport,
	19: parseExtendedClassBPositionReport,
	20: parseDataLinkManagementMessage,
	21: parseAidsToNavigationReport,
	22: parseChannelManagement,
	23: parseGroupAssignmentCommand,
	24: parseStaticDataReport,
	25: parseSingleSlotBinaryMessage,
	26: parseMultiSlotBinaryMessage,
	27: parseLongRangeAisBroadcastMessage,
}

func parseHeader(t *Codec, payload []byte, offset *uint) Header {
	p := Header{}
	var optional bool
	minLength := uint(38)
	minBitsForValid, ok := t.minValidMap["Header"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	// parsing MessageID as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.MessageID = uint8(num)

	// parsing RepeatIndicator as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.RepeatIndicator = uint8(num)

	// parsing UserID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.UserID = uint32(num)

	return p
}

func parsePositionReport(t *Codec, payload []byte, offset *uint) Packet {

	p := PositionReport{}
	var optional bool
	minLength := uint(111)
	minBitsForValid, ok := t.minValidMap["PositionReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing NavigationalStatus as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.NavigationalStatus = uint8(num)

	// parsing RateOfTurn as int16
	length = 8

	num = extractNumber(payload, true, offset, length)
	p.RateOfTurn = int16(num)

	// parsing Sog as Field10
	length = 10

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}

	// parsing PositionAccuracy as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionAccuracy = num == 1
	// parsing Longitude as FieldLatLonFine
	length = 28

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}

	// parsing Latitude as FieldLatLonFine
	length = 27

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}

	// parsing Cog as Field10
	length = 12

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}

	// parsing TrueHeading as uint16
	length = 9

	num = extractNumber(payload, false, offset, length)
	p.TrueHeading = uint16(num)

	// parsing Timestamp as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Timestamp = uint8(num)

	// parsing SpecialManoeuvreIndicator as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.SpecialManoeuvreIndicator = uint8(num)

	// parsing Spare as uint8
	length = 3

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// parsing Raim as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Raim = num == 1
	p.CommunicationStateNoItdma = parseCommunicationStateNoItdma(t, payload, offset)

	return p
}

func parseBaseStationReport(t *Codec, payload []byte, offset *uint) Packet {

	p := BaseStationReport{}
	var optional bool
	minLength := uint(111)
	minBitsForValid, ok := t.minValidMap["BaseStationReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing UtcYear as uint16
	length = 14

	num = extractNumber(payload, false, offset, length)
	p.UtcYear = uint16(num)

	// parsing UtcMonth as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.UtcMonth = uint8(num)

	// parsing UtcDay as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.UtcDay = uint8(num)

	// parsing UtcHour as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.UtcHour = uint8(num)

	// parsing UtcMinute as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.UtcMinute = uint8(num)

	// parsing UtcSecond as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.UtcSecond = uint8(num)

	// parsing PositionAccuracy as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionAccuracy = num == 1
	// parsing Longitude as FieldLatLonFine
	length = 28

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}

	// parsing Latitude as FieldLatLonFine
	length = 27

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}

	// parsing FixType as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.FixType = uint8(num)

	// parsing LongRangeEnable as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.LongRangeEnable = num == 1
	// parsing Spare as uint16
	length = 9

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint16(num)

	// parsing Raim as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Raim = num == 1
	p.CommunicationStateNoItdma = parseCommunicationStateNoItdma(t, payload, offset)

	return p
}

func parseShipStaticData(t *Codec, payload []byte, offset *uint) Packet {

	p := ShipStaticData{}
	var optional bool
	minLength := uint(386)
	minBitsForValid, ok := t.minValidMap["ShipStaticData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	var str string

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing AisVersion as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.AisVersion = uint8(num)

	// parsing ImoNumber as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.ImoNumber = uint32(num)

	// parsing CallSign as string
	length = 42
	str = extractString(payload, offset, length, t.DropSpace)
	p.CallSign = str

	// parsing Name as string
	length = 120
	str = extractString(payload, offset, length, t.DropSpace)
	p.Name = str

	// parsing Type as uint8
	length = 8

	num = extractNumber(payload, false, offset, length)
	p.Type = uint8(num)

	// parsing Dimension as FieldDimension
	length = 30
	p.Dimension = parseFieldDimension(t, payload, offset)

	// parsing FixType as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.FixType = uint8(num)

	// parsing Eta as FieldETA
	length = 20
	p.Eta = parseFieldETA(t, payload, offset)

	// parsing MaximumStaticDraught as Field10
	length = 8

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.MaximumStaticDraught = Field10(num) / 10
	} else {
		p.MaximumStaticDraught = Field10(num)
	}

	// parsing Destination as string
	length = 120
	str = extractString(payload, offset, length, t.DropSpace)
	p.Destination = str

	// parsing Dte as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Dte = num == 1
	// parsing Spare as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Spare = num == 1
	return p
}

func parseAddressedBinaryMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := AddressedBinaryMessage{}
	var optional bool
	minLength := uint(49)
	minBitsForValid, ok := t.minValidMap["AddressedBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing SequenceNumber as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.SequenceNumber = uint8(num)

	// parsing DestinationID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.DestinationID = uint32(num)

	// parsing Retransmission as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Retransmission = num == 1
	// parsing Spare as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Spare = num == 1
	// parsing ApplicationID as FieldApplicationIdentifier
	length = 16
	p.ApplicationID = parseFieldApplicationIdentifier(t, payload, offset)

	// BinaryData is an array of bytes
	length = uint(len(payload)) - *offset
	p.BinaryData = payload[*offset : *offset+length]
	*offset += length

	return p
}

func parseBinaryBroadcastMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := BinaryBroadcastMessage{}
	var optional bool
	minLength := uint(17)
	minBitsForValid, ok := t.minValidMap["BinaryBroadcastMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// parsing ApplicationID as FieldApplicationIdentifier
	length = 16
	p.ApplicationID = parseFieldApplicationIdentifier(t, payload, offset)

	// BinaryData is an array of bytes
	length = uint(len(payload)) - *offset
	p.BinaryData = payload[*offset : *offset+length]
	*offset += length

	return p
}

func parseStandardSearchAndRescueAircraftReport(t *Codec, payload []byte, offset *uint) Packet {

	p := StandardSearchAndRescueAircraftReport{}
	var optional bool
	minLength := uint(110)
	minBitsForValid, ok := t.minValidMap["StandardSearchAndRescueAircraftReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Altitude as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.Altitude = uint16(num)

	// parsing Sog as uint16
	length = 10

	num = extractNumber(payload, false, offset, length)
	p.Sog = uint16(num)

	// parsing PositionAccuracy as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionAccuracy = num == 1
	// parsing Longitude as FieldLatLonFine
	length = 28

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}

	// parsing Latitude as FieldLatLonFine
	length = 27

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}

	// parsing Cog as Field10
	length = 12

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}

	// parsing Timestamp as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Timestamp = uint8(num)

	// parsing AltFromBaro as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.AltFromBaro = num == 1
	// parsing Spare1 as uint8
	length = 7

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing Dte as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Dte = num == 1
	// parsing Spare2 as uint8
	length = 3

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	// parsing AssignedMode as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.AssignedMode = num == 1
	// parsing Raim as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Raim = num == 1
	p.CommunicationStateItdma = parseCommunicationStateItdma(t, payload, offset)

	return p
}

func parseCoordinatedUTCInquiry(t *Codec, payload []byte, offset *uint) Packet {

	p := CoordinatedUTCInquiry{}
	var optional bool
	minLength := uint(34)
	minBitsForValid, ok := t.minValidMap["CoordinatedUTCInquiry"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare1 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing DestinationID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.DestinationID = uint32(num)

	// parsing Spare2 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	return p
}

func parseAddessedSafetyMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := AddessedSafetyMessage{}
	var optional bool
	minLength := uint(33)
	minBitsForValid, ok := t.minValidMap["AddessedSafetyMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	var str string

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing SequenceNumber as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.SequenceNumber = uint8(num)

	// parsing DestinationID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.DestinationID = uint32(num)

	// parsing Retransmission as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Retransmission = num == 1
	// parsing Spare as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Spare = num == 1
	// parsing Text as string
	// TODO check minlength less than payload length... TODO check if there is a better way to calculate the variable length...
	length = uint(len(payload)) - minLength
	str = extractString(payload, offset, length, t.DropSpace)
	p.Text = str

	return p
}

func parseSafetyBroadcastMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := SafetyBroadcastMessage{}
	var optional bool
	minLength := uint(1)
	minBitsForValid, ok := t.minValidMap["SafetyBroadcastMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	var str string

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// parsing Text as string
	// TODO check minlength less than payload length... TODO check if there is a better way to calculate the variable length...
	length = uint(len(payload)) - minLength
	str = extractString(payload, offset, length, t.DropSpace)
	p.Text = str

	return p
}

func parseGnssBroadcastBinaryMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := GnssBroadcastBinaryMessage{}
	var optional bool
	minLength := uint(41)
	minBitsForValid, ok := t.minValidMap["GnssBroadcastBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare1 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing Longitude as FieldLatLonCoarse
	length = 18

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude = FieldLatLonCoarse(num)
	}

	// parsing Latitude as FieldLatLonCoarse
	length = 17

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude = FieldLatLonCoarse(num)
	}

	// parsing Spare2 as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	// Data is an array of bytes
	length = uint(len(payload)) - *offset
	p.Data = payload[*offset : *offset+length]
	*offset += length

	return p
}

func parseStandardClassBPositionReport(t *Codec, payload []byte, offset *uint) Packet {

	p := StandardClassBPositionReport{}
	var optional bool
	minLength := uint(110)
	minBitsForValid, ok := t.minValidMap["StandardClassBPositionReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare1 as uint8
	length = 8

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing Sog as Field10
	length = 10

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}

	// parsing PositionAccuracy as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionAccuracy = num == 1
	// parsing Longitude as FieldLatLonFine
	length = 28

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}

	// parsing Latitude as FieldLatLonFine
	length = 27

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}

	// parsing Cog as Field10
	length = 12

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}

	// parsing TrueHeading as uint16
	length = 9

	num = extractNumber(payload, false, offset, length)
	p.TrueHeading = uint16(num)

	// parsing Timestamp as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Timestamp = uint8(num)

	// parsing Spare2 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	// parsing ClassBUnit as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.ClassBUnit = num == 1
	// parsing ClassBDisplay as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.ClassBDisplay = num == 1
	// parsing ClassBDsc as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.ClassBDsc = num == 1
	// parsing ClassBBand as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.ClassBBand = num == 1
	// parsing ClassBMsg22 as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.ClassBMsg22 = num == 1
	// parsing AssignedMode as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.AssignedMode = num == 1
	// parsing Raim as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Raim = num == 1
	p.CommunicationStateItdma = parseCommunicationStateItdma(t, payload, offset)

	return p
}

func parseExtendedClassBPositionReport(t *Codec, payload []byte, offset *uint) Packet {

	p := ExtendedClassBPositionReport{}
	var optional bool
	minLength := uint(274)
	minBitsForValid, ok := t.minValidMap["ExtendedClassBPositionReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	var str string

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare1 as uint8
	length = 8

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing Sog as Field10
	length = 10

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.Sog = Field10(num) / 10
	} else {
		p.Sog = Field10(num)
	}

	// parsing PositionAccuracy as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionAccuracy = num == 1
	// parsing Longitude as FieldLatLonFine
	length = 28

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}

	// parsing Latitude as FieldLatLonFine
	length = 27

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}

	// parsing Cog as Field10
	length = 12

	num = extractNumber(payload, false, offset, length)
	if !t.FloatWithoutConversion {
		p.Cog = Field10(num) / 10
	} else {
		p.Cog = Field10(num)
	}

	// parsing TrueHeading as uint16
	length = 9

	num = extractNumber(payload, false, offset, length)
	p.TrueHeading = uint16(num)

	// parsing Timestamp as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Timestamp = uint8(num)

	// parsing Spare2 as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	// parsing Name as string
	length = 120
	str = extractString(payload, offset, length, t.DropSpace)
	p.Name = str

	// parsing Type as uint8
	length = 8

	num = extractNumber(payload, false, offset, length)
	p.Type = uint8(num)

	// parsing Dimension as FieldDimension
	length = 30
	p.Dimension = parseFieldDimension(t, payload, offset)

	// parsing FixType as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.FixType = uint8(num)

	// parsing Raim as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Raim = num == 1
	// parsing Dte as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Dte = num == 1
	// parsing AssignedMode as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.AssignedMode = num == 1
	// parsing Spare3 as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.Spare3 = uint8(num)

	return p
}

func parseAidsToNavigationReport(t *Codec, payload []byte, offset *uint) Packet {

	p := AidsToNavigationReport{}
	var optional bool
	minLength := uint(233)
	minBitsForValid, ok := t.minValidMap["AidsToNavigationReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	var str string

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Type as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.Type = uint8(num)

	// parsing Name as string
	length = 120
	str = extractString(payload, offset, length, t.DropSpace)
	p.Name = str

	// parsing PositionAccuracy as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionAccuracy = num == 1
	// parsing Longitude as FieldLatLonFine
	length = 28

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Longitude = FieldLatLonFine(num)
	}

	// parsing Latitude as FieldLatLonFine
	length = 27

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.Latitude = FieldLatLonFine(num)
	}

	// parsing Dimension as FieldDimension
	length = 30
	p.Dimension = parseFieldDimension(t, payload, offset)

	// parsing Fixtype as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.Fixtype = uint8(num)

	// parsing Timestamp as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Timestamp = uint8(num)

	// parsing OffPosition as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.OffPosition = num == 1
	// parsing AtoN as uint8
	length = 8

	num = extractNumber(payload, false, offset, length)
	p.AtoN = uint8(num)

	// parsing Raim as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Raim = num == 1
	// parsing VirtualAtoN as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.VirtualAtoN = num == 1
	// parsing AssignedMode as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.AssignedMode = num == 1
	// parsing Spare as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Spare = num == 1
	// parsing NameExtension as string
	// TODO check minlength less than payload length... TODO check if there is a better way to calculate the variable length...
	length = uint(len(payload)) - minLength
	str = extractString(payload, offset, length, t.DropSpace)
	p.NameExtension = str

	return p
}

func parseGroupAssignmentCommand(t *Codec, payload []byte, offset *uint) Packet {

	p := GroupAssignmentCommand{}
	var optional bool
	minLength := uint(122)
	minBitsForValid, ok := t.minValidMap["GroupAssignmentCommand"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare1 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing Longitude1 as FieldLatLonCoarse
	length = 18

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude1 = FieldLatLonCoarse(num)
	}

	// parsing Latitude1 as FieldLatLonCoarse
	length = 17

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude1 = FieldLatLonCoarse(num)
	}

	// parsing Longitude2 as FieldLatLonCoarse
	length = 18

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude2 = FieldLatLonCoarse(num)
	}

	// parsing Latitude2 as FieldLatLonCoarse
	length = 17

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude2 = FieldLatLonCoarse(num)
	}

	// parsing StationType as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.StationType = uint8(num)

	// parsing ShipType as uint8
	length = 8

	num = extractNumber(payload, false, offset, length)
	p.ShipType = uint8(num)

	// parsing Spare2 as uint32
	length = 22

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint32(num)

	// parsing TxRxMode as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.TxRxMode = uint8(num)

	// parsing ReportingInterval as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.ReportingInterval = uint8(num)

	// parsing QuietTime as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.QuietTime = uint8(num)

	// parsing Spare3 as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Spare3 = uint8(num)

	return p
}

func parseStaticDataReportA(t *Codec, payload []byte, offset *uint) StaticDataReportA {
	p := StaticDataReportA{}
	var optional bool
	minLength := uint(120)
	minBitsForValid, ok := t.minValidMap["StaticDataReportA"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var str string

	p.Valid = true

	// parsing Name as string
	length = 120
	str = extractString(payload, offset, length, t.DropSpace)
	p.Name = str

	return p
}

func parseStaticDataReportB(t *Codec, payload []byte, offset *uint) StaticDataReportB {
	p := StaticDataReportB{}
	var optional bool
	minLength := uint(128)
	minBitsForValid, ok := t.minValidMap["StaticDataReportB"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	var str string

	p.Valid = true

	// parsing ShipType as uint8
	length = 8

	num = extractNumber(payload, false, offset, length)
	p.ShipType = uint8(num)

	// parsing VendorIDName as string
	length = 18
	str = extractString(payload, offset, length, t.DropSpace)
	p.VendorIDName = str

	// parsing VenderIDModel as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.VenderIDModel = uint8(num)

	// parsing VenderIDSerial as uint32
	length = 20

	num = extractNumber(payload, false, offset, length)
	p.VenderIDSerial = uint32(num)

	// parsing CallSign as string
	length = 42
	str = extractString(payload, offset, length, t.DropSpace)
	p.CallSign = str

	// parsing Dimension as FieldDimension
	length = 30
	p.Dimension = parseFieldDimension(t, payload, offset)

	// parsing FixType as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.FixType = uint8(num)

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	return p
}

func parseStaticDataReport(t *Codec, payload []byte, offset *uint) Packet {

	p := StaticDataReport{}
	var optional bool
	minLength := uint(242)
	minBitsForValid, ok := t.minValidMap["StaticDataReport"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Reserved as uint8
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Reserved = uint8(num)

	// parsing PartNumber as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PartNumber = num == 1
	// parsing ReportA as StaticDataReportA(optional)
	if len(payload) < 39 {
		// todo set Valid=false??
		return nil
	}
	if payload[39] == 0 {

		length = 120
		p.ReportA = parseStaticDataReportA(t, payload, offset)

	}

	// parsing ReportB as StaticDataReportB(optional)
	if len(payload) < 39 {
		// todo set Valid=false??
		return nil
	}
	if payload[39] == 1 {

		length = 120
		p.ReportB = parseStaticDataReportB(t, payload, offset)

	}

	return p
}

func parseLongRangeAisBroadcastMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := LongRangeAisBroadcastMessage{}
	var optional bool
	minLength := uint(58)
	minBitsForValid, ok := t.minValidMap["LongRangeAisBroadcastMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing PositionAccuracy as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionAccuracy = num == 1
	// parsing Raim as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Raim = num == 1
	// parsing NavigationalStatus as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.NavigationalStatus = uint8(num)

	// parsing Longitude as FieldLatLonCoarse
	length = 18

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude = FieldLatLonCoarse(num)
	}

	// parsing Latitude as FieldLatLonCoarse
	length = 17

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude = FieldLatLonCoarse(num)
	}

	// parsing Sog as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Sog = uint8(num)

	// parsing Cog as uint16
	length = 9

	num = extractNumber(payload, false, offset, length)
	p.Cog = uint16(num)

	// parsing PositionLatency as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.PositionLatency = num == 1
	// parsing Spare as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.Spare = num == 1
	return p
}

func parseBinaryAcknowledgeData(t *Codec, payload []byte, offset *uint) BinaryAcknowledgeData {
	p := BinaryAcknowledgeData{}
	var optional bool
	minLength := uint(32)
	minBitsForValid, ok := t.minValidMap["BinaryAcknowledgeData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Valid = true

	// parsing DestinationID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.DestinationID = uint32(num)

	// parsing SequenceNumber as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.SequenceNumber = uint8(num)

	return p
}

func parseBinaryAcknowledge(t *Codec, payload []byte, offset *uint) Packet {

	p := BinaryAcknowledge{}
	var optional bool
	minLength := uint(2)
	minBitsForValid, ok := t.minValidMap["BinaryAcknowledge"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// Destinations is an array of BinaryAcknowledgeDatas
	var elems [4]BinaryAcknowledgeData
	elems[0] = parseBinaryAcknowledgeData(t, payload, offset)
	elems[1] = parseBinaryAcknowledgeData(t, payload, offset)
	elems[2] = parseBinaryAcknowledgeData(t, payload, offset)
	elems[3] = parseBinaryAcknowledgeData(t, payload, offset)
	p.Destinations = elems
	return p
}

func parseInterrogationStation1Message1(t *Codec, payload []byte, offset *uint) InterrogationStation1Message1 {
	p := InterrogationStation1Message1{}
	var optional bool
	minLength := uint(48)
	minBitsForValid, ok := t.minValidMap["InterrogationStation1Message1"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Valid = true

	// parsing StationID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.StationID = uint32(num)

	// parsing MessageID as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.MessageID = uint8(num)

	// parsing SlotOffset as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.SlotOffset = uint16(num)

	return p
}

func parseInterrogationStation1Message2(t *Codec, payload []byte, offset *uint) InterrogationStation1Message2 {
	p := InterrogationStation1Message2{}
	var optional bool
	minLength := uint(20)
	minBitsForValid, ok := t.minValidMap["InterrogationStation1Message2"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Valid = true

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// parsing MessageID as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.MessageID = uint8(num)

	// parsing SlotOffset as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.SlotOffset = uint16(num)

	return p
}

func parseInterrogationStation2(t *Codec, payload []byte, offset *uint) InterrogationStation2 {
	p := InterrogationStation2{}
	var optional bool
	minLength := uint(52)
	minBitsForValid, ok := t.minValidMap["InterrogationStation2"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Valid = true

	// parsing Spare1 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing StationID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.StationID = uint32(num)

	// parsing MessageID as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.MessageID = uint8(num)

	// parsing SlotOffset as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.SlotOffset = uint16(num)

	// parsing Spare2 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	return p
}

func parseInterrogation(t *Codec, payload []byte, offset *uint) Packet {

	p := Interrogation{}
	var optional bool
	minLength := uint(50)
	minBitsForValid, ok := t.minValidMap["Interrogation"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// parsing Station1Msg1 as InterrogationStation1Message1
	length = 48
	p.Station1Msg1 = parseInterrogationStation1Message1(t, payload, offset)

	// parsing Station1Msg2 as InterrogationStation1Message2
	length = 0
	p.Station1Msg2 = parseInterrogationStation1Message2(t, payload, offset)

	// parsing Station2 as InterrogationStation2
	length = 0
	p.Station2 = parseInterrogationStation2(t, payload, offset)

	return p
}

func parseAssignedModeCommandData(t *Codec, payload []byte, offset *uint) AssignedModeCommandData {
	p := AssignedModeCommandData{}
	var optional bool
	minLength := uint(52)
	minBitsForValid, ok := t.minValidMap["AssignedModeCommandData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Valid = true

	// parsing DestinationID as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.DestinationID = uint32(num)

	// parsing Offset as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.Offset = uint16(num)

	// parsing Increment as uint16
	length = 10

	num = extractNumber(payload, false, offset, length)
	p.Increment = uint16(num)

	return p
}

func parseAssignedModeCommand(t *Codec, payload []byte, offset *uint) Packet {

	p := AssignedModeCommand{}
	var optional bool
	minLength := uint(2)
	minBitsForValid, ok := t.minValidMap["AssignedModeCommand"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// Commands is an array of AssignedModeCommandDatas
	var elems [2]AssignedModeCommandData
	elems[0] = parseAssignedModeCommandData(t, payload, offset)
	elems[1] = parseAssignedModeCommandData(t, payload, offset)
	p.Commands = elems
	return p
}

func parseDataLinkManagementMessageData(t *Codec, payload []byte, offset *uint) DataLinkManagementMessageData {
	p := DataLinkManagementMessageData{}
	var optional bool
	minLength := uint(30)
	minBitsForValid, ok := t.minValidMap["DataLinkManagementMessageData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Valid = true

	// parsing Offset as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.Offset = uint16(num)

	// parsing NumberOfSlots as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.NumberOfSlots = uint8(num)

	// parsing TimeOut as uint8
	length = 3

	num = extractNumber(payload, false, offset, length)
	p.TimeOut = uint8(num)

	// parsing Increment as uint16
	length = 11

	num = extractNumber(payload, false, offset, length)
	p.Increment = uint16(num)

	return p
}

func parseDataLinkManagementMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := DataLinkManagementMessage{}
	var optional bool
	minLength := uint(2)
	minBitsForValid, ok := t.minValidMap["DataLinkManagementMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare = uint8(num)

	// Data is an array of DataLinkManagementMessageDatas
	var elems [4]DataLinkManagementMessageData
	elems[0] = parseDataLinkManagementMessageData(t, payload, offset)
	elems[1] = parseDataLinkManagementMessageData(t, payload, offset)
	elems[2] = parseDataLinkManagementMessageData(t, payload, offset)
	elems[3] = parseDataLinkManagementMessageData(t, payload, offset)
	p.Data = elems
	return p
}

func parseChannelManagementBroadcastData(t *Codec, payload []byte, offset *uint) ChannelManagementBroadcastData {
	p := ChannelManagementBroadcastData{}
	var optional bool
	minLength := uint(70)
	minBitsForValid, ok := t.minValidMap["ChannelManagementBroadcastData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	// parsing Longitude1 as FieldLatLonCoarse
	length = 18

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude1 = FieldLatLonCoarse(num)
	}

	// parsing Latitude1 as FieldLatLonCoarse
	length = 17

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude1 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude1 = FieldLatLonCoarse(num)
	}

	// parsing Longitude2 as FieldLatLonCoarse
	length = 18

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Longitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Longitude2 = FieldLatLonCoarse(num)
	}

	// parsing Latitude2 as FieldLatLonCoarse
	length = 17

	num = extractNumber(payload, true, offset, length)
	if !t.FloatWithoutConversion {
		p.Latitude2 = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.Latitude2 = FieldLatLonCoarse(num)
	}

	return p
}

func parseChannelManagementUnicastData(t *Codec, payload []byte, offset *uint) ChannelManagementUnicastData {
	p := ChannelManagementUnicastData{}
	var optional bool
	minLength := uint(70)
	minBitsForValid, ok := t.minValidMap["ChannelManagementUnicastData"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	// parsing AddressStation1 as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.AddressStation1 = uint32(num)

	// parsing Spare2 as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	// parsing AddressStation2 as uint32
	length = 30

	num = extractNumber(payload, false, offset, length)
	p.AddressStation2 = uint32(num)

	// parsing Spare3 as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.Spare3 = uint8(num)

	return p
}

func parseChannelManagement(t *Codec, payload []byte, offset *uint) Packet {

	p := ChannelManagement{}
	var optional bool
	minLength := uint(200)
	minBitsForValid, ok := t.minValidMap["ChannelManagement"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing Spare1 as uint8
	length = 2

	num = extractNumber(payload, false, offset, length)
	p.Spare1 = uint8(num)

	// parsing ChannelA as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.ChannelA = uint16(num)

	// parsing ChannelB as uint16
	length = 12

	num = extractNumber(payload, false, offset, length)
	p.ChannelB = uint16(num)

	// parsing TxRxMode as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.TxRxMode = uint8(num)

	// parsing LowPower as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.LowPower = num == 1
	// parsing Area as ChannelManagementBroadcastData(optional)
	if len(payload) < 139 {
		// todo set Valid=false??
		return nil
	}
	if payload[139] == 0 {

		length = 70
		p.Area = parseChannelManagementBroadcastData(t, payload, offset)

	}

	// parsing Unicast as ChannelManagementUnicastData(optional)
	if len(payload) < 139 {
		// todo set Valid=false??
		return nil
	}
	if payload[139] == 1 {

		length = 70
		p.Unicast = parseChannelManagementUnicastData(t, payload, offset)

	}

	// parsing IsAddressed as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.IsAddressed = num == 1
	// parsing BwA as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.BwA = num == 1
	// parsing BwB as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.BwB = num == 1
	// parsing TransitionalZoneSize as uint8
	length = 3

	num = extractNumber(payload, false, offset, length)
	p.TransitionalZoneSize = uint8(num)

	// parsing Spare4 as uint32
	length = 23

	num = extractNumber(payload, false, offset, length)
	p.Spare4 = uint32(num)

	return p
}

func parseSingleSlotBinaryMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := SingleSlotBinaryMessage{}
	var optional bool
	minLength := uint(49)
	minBitsForValid, ok := t.minValidMap["SingleSlotBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing DestinationIDValid as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.DestinationIDValid = num == 1
	// parsing ApplicationIDValid as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.ApplicationIDValid = num == 1
	// parsing DestinationID as uint32(optional)
	if len(payload) < 38 {
		// todo set Valid=false??
		return nil
	}
	if payload[38] == 1 {

		length = 30

		num = extractNumber(payload, false, offset, length)
		p.DestinationID = uint32(num)

	}

	// parsing Spare as uint8(optional)
	if len(payload) < 38 {
		// todo set Valid=false??
		return nil
	}
	if payload[38] == 1 {

		length = 2

		num = extractNumber(payload, false, offset, length)
		p.Spare = uint8(num)

	}

	// parsing ApplicationID as FieldApplicationIdentifier(optional)
	if len(payload) < 39 {
		// todo set Valid=false??
		return nil
	}
	if payload[39] == 1 {

		length = 16
		p.ApplicationID = parseFieldApplicationIdentifier(t, payload, offset)

	}

	// Payload is an array of bytes
	length = uint(len(payload)) - *offset
	p.Payload = payload[*offset : *offset+length]
	*offset += length

	return p
}

func parseMultiSlotBinaryMessage(t *Codec, payload []byte, offset *uint) Packet {

	p := MultiSlotBinaryMessage{}
	var optional bool
	minLength := uint(53)
	minBitsForValid, ok := t.minValidMap["MultiSlotBinaryMessage"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Header = parseHeader(t, payload, offset)

	p.Valid = true

	// parsing DestinationIDValid as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.DestinationIDValid = num == 1
	// parsing ApplicationIDValid as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.ApplicationIDValid = num == 1
	// parsing DestinationID as uint32(optional)
	if len(payload) < 38 {
		// todo set Valid=false??
		return nil
	}
	if payload[38] == 1 {

		length = 30

		num = extractNumber(payload, false, offset, length)
		p.DestinationID = uint32(num)

	}

	// parsing Spare1 as uint8(optional)
	if len(payload) < 38 {
		// todo set Valid=false??
		return nil
	}
	if payload[38] == 1 {

		length = 2

		num = extractNumber(payload, false, offset, length)
		p.Spare1 = uint8(num)

	}

	// parsing ApplicationID as FieldApplicationIdentifier(optional)
	if len(payload) < 39 {
		// todo set Valid=false??
		return nil
	}
	if payload[39] == 1 {

		length = 16
		p.ApplicationID = parseFieldApplicationIdentifier(t, payload, offset)

	}

	// Payload is an array of bytes
	length = uint(len(payload)) - *offset
	p.Payload = payload[*offset : *offset+length]
	*offset += length

	// parsing Spare2 as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.Spare2 = uint8(num)

	p.CommunicationStateItdma = parseCommunicationStateItdma(t, payload, offset)

	return p
}

func parseFieldETA(t *Codec, payload []byte, offset *uint) FieldETA {
	p := FieldETA{}
	var optional bool
	minLength := uint(20)
	minBitsForValid, ok := t.minValidMap["FieldETA"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	// parsing Month as uint8
	length = 4

	num = extractNumber(payload, false, offset, length)
	p.Month = uint8(num)

	// parsing Day as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.Day = uint8(num)

	// parsing Hour as uint8
	length = 5

	num = extractNumber(payload, false, offset, length)
	p.Hour = uint8(num)

	// parsing Minute as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.Minute = uint8(num)

	return p
}

func parseFieldDimension(t *Codec, payload []byte, offset *uint) FieldDimension {
	p := FieldDimension{}
	var optional bool
	minLength := uint(30)
	minBitsForValid, ok := t.minValidMap["FieldDimension"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	// parsing A as uint16
	length = 9

	num = extractNumber(payload, false, offset, length)
	p.A = uint16(num)

	// parsing B as uint16
	length = 9

	num = extractNumber(payload, false, offset, length)
	p.B = uint16(num)

	// parsing C as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.C = uint8(num)

	// parsing D as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.D = uint8(num)

	return p
}

func parseFieldApplicationIdentifier(t *Codec, payload []byte, offset *uint) FieldApplicationIdentifier {
	p := FieldApplicationIdentifier{}
	var optional bool
	minLength := uint(16)
	minBitsForValid, ok := t.minValidMap["FieldApplicationIdentifier"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	p.Valid = true

	// parsing DesignatedAreaCode as uint16
	length = 10

	num = extractNumber(payload, false, offset, length)
	p.DesignatedAreaCode = uint16(num)

	// parsing FunctionIdentifier as uint8
	length = 6

	num = extractNumber(payload, false, offset, length)
	p.FunctionIdentifier = uint8(num)

	return p
}

func parseCommunicationStateItdma(t *Codec, payload []byte, offset *uint) CommunicationStateItdma {
	p := CommunicationStateItdma{}
	var optional bool
	minLength := uint(20)
	minBitsForValid, ok := t.minValidMap["CommunicationStateItdma"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	// parsing CommunicationStateIsItdma as bool
	length = 1

	num = extractNumber(payload, false, offset, length)
	p.CommunicationStateIsItdma = num == 1
	// parsing CommunicationState as uint32
	length = 19

	num = extractNumber(payload, false, offset, length)
	p.CommunicationState = uint32(num)

	return p
}

func parseCommunicationStateNoItdma(t *Codec, payload []byte, offset *uint) CommunicationStateNoItdma {
	p := CommunicationStateNoItdma{}
	var optional bool
	minLength := uint(19)
	minBitsForValid, ok := t.minValidMap["CommunicationStateNoItdma"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return p
		}
		log.Println("ERROR: -1 PositionReport too short")
		return p
	}
	var length uint

	var num int64

	// parsing CommunicationState as uint32
	length = 19

	num = extractNumber(payload, false, offset, length)
	p.CommunicationState = uint32(num)

	return p
}
