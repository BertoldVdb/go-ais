package main

import (
	"flag"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path"
	"strconv"
	"strings"
	"unicode"
)

var inputFile = flag.String("input", "", "Input file")
var outputDir = flag.String("output", "", "Output directory")

var msgMap = map[int]string{
	1:  "PositionReport",
	2:  "PositionReport",
	3:  "PositionReport",
	4:  "BaseStationReport",
	5:  "ShipStaticData",
	6:  "AddressedBinaryMessage",
	7:  "BinaryAcknowledge",
	8:  "BinaryBroadcastMessage",
	9:  "StandardSearchAndRescueAircraftReport",
	10: "CoordinatedUTCInquiry",
	11: "BaseStationReport",
	12: "AddessedSafetyMessage",
	13: "BinaryAcknowledge",
	14: "SafetyBroadcastMessage",
	15: "Interrogation",
	16: "AssignedModeCommand",
	17: "GnssBroadcastBinaryMessage",
	18: "StandardClassBPositionReport",
	19: "ExtendedClassBPositionReport",
	20: "DataLinkManagementMessage",
	21: "AidsToNavigationReport",
	22: "ChannelManagement",
	23: "GroupAssignmentCommand",
	24: "StaticDataReport",
	25: "SingleSlotBinaryMessage",
	26: "MultiSlotBinaryMessage",
	27: "LongRangeAisBroadcastMessage",
}
var numberTypes = map[string]struct{}{
	"ChannelManagementUnicastData":   struct{}{},
	"ChannelManagementBroadcastData": struct{}{},
	"InterrogationStation2":          struct{}{},
	"InterrogationStation1Message1":  struct{}{},
	"InterrogationStation1Message2":  struct{}{},
	"StaticDataReportA":              struct{}{},
	"StaticDataReportB":              struct{}{},
	"FieldApplicationIdentifier":     struct{}{},
	"FieldETA":                       struct{}{},
	"FieldDimension":                 struct{}{},
	"FieldLatLonFine":                struct{}{},
	"FieldLatLonCoarse":              struct{}{},
	"Field10":                        struct{}{},
	"bool":                           struct{}{},
	"int16":                          struct{}{},
	"uint16":                         struct{}{},
	"uint32":                         struct{}{},
	"uint8":                          struct{}{},
}

type fieldType struct {
	name        string
	typ         string
	width       int
	embedded    bool
	isArray     bool
	arrayLength int
}

func main() {
	flag.Parse()
	log.Println("Working on", *inputFile)
	if *outputDir == "" {
		var err error
		*outputDir, err = os.Getwd()
		if err != nil {
			panic(err)
		}
	}
	log.Println("output files go in", *outputDir)

	//contents, err := ioutil.ReadFile(*inputFile)
	//if err != nil {
	//	panic(err)
	//}
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, *inputFile, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	output := `
// package ais WARNING: This file is generated by parser_generator/main.go do not edit directly.
package ais
import "log"
`
	for _, decl := range f.Decls {
		// if it is a struct
		st, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if st.Tok == token.TYPE {
			for _, spec := range st.Specs {
				typespec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				structType, ok := typespec.Type.(*ast.StructType)
				if !ok {
					continue
				}
				name := typespec.Name.Name
				if !unicode.IsUpper(rune(name[0])) {
					continue
				}

				log.Println("Found type to generate: ", name)

				var minLength = uint(0)
				fields := []fieldType{}
				for _, field := range structType.Fields.List {
					if len(field.Names) == 0 {
						// it's probably the header embed or communicationStateNoItdma
						fields = append(fields, fieldType{
							embedded: true,
							typ:      field.Type.(*ast.Ident).Name,
						})
						continue
					}
					fieldName := field.Names[0].Name
					var typ string
					var isArray bool
					var arrayLength int
					switch msg := field.Type.(type) {
					case *ast.Ident:
						typ = msg.Name
					case *ast.ArrayType:
						var length string
						isArray = true
						if msg.Len != nil && msg.Len.(*ast.BasicLit).Kind == token.INT {
							length = msg.Len.(*ast.BasicLit).Value
							arrayLength, err = strconv.Atoi(length)
							if err != nil {
								panic(err)
							}
						}
						typ = msg.Elt.(*ast.Ident).Name
					}
					if field.Tag == nil {
						continue
					}
					tags := strings.Split(field.Tag.Value, " ")
					var width int
					for _, tag := range tags {
						parts := strings.Split(tag, ":")
						if len(parts) > 2 {
							panic("unepxected multiple parts to tag")
						}
						//I.E aiswidth:6
						if parts[0] == "aiswidth" {
							width, err = strconv.Atoi(parts[1])
							if err != nil {
								panic(err)
							}
							minLength += uint(width)
						} else if parts[0] == "aisDependsBit" {

						} else if parts[0] == "aisoptional" {
							// TODO support this...
							// optional = true
						} else if parts[0] == "aisEncodeMaxLen" {
							ml, err := strconv.Atoi(parts[1])
							if err != nil {
								panic(err)
							}
							if ml < 0 {
								panic("impossible to have a negative aisEncodeMaxLen but got " + parts[1])
							}
							minLength = uint(ml)
						}

					}
					log.Println("\t", fieldName, typ, tags, width)
					fields = append(fields, fieldType{
						name:        fieldName,
						typ:         typ,
						width:       width,
						arrayLength: arrayLength,
						isArray:     isArray,
					})
				}

				output += `func parse` + name + `(payload []byte, t *Codec, offset *uint) *` + name + ` {
	p := &` + name + `{}
// TODO if it has a valid field then write it here...
	var optional bool
	minLength := uint(` + strconv.Itoa(int(minLength)) + `)
    minBitsForValid, ok := t.minValidMap["` + name + `"]
	if !ok {
		minBitsForValid = minLength
	}
	if len(payload)-int(*offset) < int(minBitsForValid) {
		if optional {
			return nil
		}
		log.Println("ERROR: -1 PositionReport too short")
		return nil
	}
    `

				var (
					hasNumberParseable bool
					hasStringParseable bool
				)

				for _, field := range fields {
					if field.typ == "string" {
						hasStringParseable = true
					}
					if _, ok := numberTypes[field.typ]; ok {
						hasNumberParseable = true
					}
				}

				if hasNumberParseable {
					output += `
	var num int64
`
				}
				if hasStringParseable {
					output += `
	var str string
`
				}

				for _, field := range fields {

					if field.embedded {
						output += `
	p.` + field.typ + ` = *parse` + field.typ + `(payload, t, offset)
`
					} else if field.isArray {
						switch field.typ {
						case "AssignedModeCommandData":
						case "BinaryAcknowledgeData":
						case "DataLinkManagementMessageData":
							output += `var elems [` + strconv.Itoa(field.arrayLength) + `]` + field.typ + `
`
							for i := 0; i < field.arrayLength; i++ {
								output += `elems[` + strconv.Itoa(i) + `] = *parse` + field.typ + `(payload, t, offset)
`
							}
							output += `p.` + field.name + ` = elems`
						case "byte":
							output += `p.` + field.name + ` = payload[*offset:*offset+` + strconv.Itoa(field.arrayLength) + `]
	*offset += ` + strconv.Itoa(field.arrayLength) + `
`
						}
					} else {
						output += "// parsing " + field.name + " as " + field.typ + "\n"
						// simple type parsing
						switch field.typ {
						case "ChannelManagementUnicastData":
						case "ChannelManagementBroadcastData":
						case "InterrogationStation2":
						case "InterrogationStation1Message1":
						case "InterrogationStation1Message2":
						case "StaticDataReportA":
						case "StaticDataReportB":
						case "FieldApplicationIdentifier":
						case "FieldETA":
						case "FieldDimension":
							output += `p.` + field.name + ` = *parseFieldDimension(payload, t, offset)
`
						case "FieldLatLonFine":
							output += `
	num = extractNumber(payload, true, offset, ` + strconv.Itoa(field.width) + `)
	if !t.FloatWithoutConversion {
		p.` + field.name + ` = FieldLatLonFine(num) / 10000 / 60
	} else {
		p.` + field.name + ` = FieldLatLonFine(num)
	}
`
						case "FieldLatLonCoarse":
							output += `
	num = extractNumber(payload, true, offset, ` + strconv.Itoa(field.width) + `)
	if !t.FloatWithoutConversion {
		p.` + field.name + ` = FieldLatLonCoarse(num) / 10 / 60
	} else {
		p.` + field.name + ` = FieldLatLonCoarse(num)
	}
`
						case "Field10":
							output += `
	num = extractNumber(payload, true, offset, ` + strconv.Itoa(field.width) + `)
	if !t.FloatWithoutConversion {
		p.` + field.name + ` = Field10(num) / 10
	} else {
		p.` + field.name + ` = Field10(num)
	}
`
						case "bool":
							output += `
	num = extractNumber(payload, true, offset, ` + strconv.Itoa(field.width) + `)
	p.` + field.name + ` = num == 1`
						case "int16":
							output += `
	num = extractNumber(payload, true, offset, ` + strconv.Itoa(field.width) + `)
	p.` + field.name + ` = int16(num)
`
						case "string":
							output += `str = extractString(payload, offset, ` + strconv.Itoa(field.width) + `, t.DropSpace)
	p.` + field.name + ` = str
`
						case "uint16":
							output += `
	num = extractNumber(payload, false, offset, ` + strconv.Itoa(field.width) + `)
	p.` + field.name + ` = uint16(num)
`
						case "uint32":
							output += `
	num = extractNumber(payload, false, offset, ` + strconv.Itoa(field.width) + `)
	p.` + field.name + ` = uint32(num)
`
						case "uint8":
							output += `
	num = extractNumber(payload, false, offset, ` + strconv.Itoa(field.width) + `)
	p.` + field.name + ` = uint8(num)
`
						default:
							panic("unhandled type: " + field.typ)
						}
					}

				}
				output += `
	return p
}

`
			}
		}
	}

	// now output back to a file
	outputPath := path.Join(*outputDir, "codec_gen.go")
	formattedContent, err := format.Source([]byte(output))
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(outputPath, formattedContent, 0644)
	if err != nil {
		panic(err)
	}
	log.Println("generated: ", outputPath)
}
